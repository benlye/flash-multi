#!/bin/bash
shopt -s extglob

# *********************************************************************
# Copyright (C) 2019 Ben Lye

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
# *********************************************************************

# Define the script version
VERSION=0.1.6

# Write the script header
printf "flash-multi $VERSION\n\nThis program is Free Software and has NO WARRANTY.\nhttps://github.com/benlye/flash-multi/\n\n";

# Prepare simple help text to display when needed
USAGE="Usage: flash-multi -f [firmware file] -p [serial device]\n\n"

# Get the command line options
while getopts ":f:p:h" opt; do
  case $opt in
    f) FWFILE="$OPTARG"
    ;;
    p) PORT="$OPTARG"
    ;;
    h) printf "$USAGE"; exit 1
    ;;
    \?) printf "Invalid argument -$OPTARG\n\n"; >&2
    ;;
    :) printf "Missing value for argument -$OPTARG\n\n"; >&2
    ;;
  esac
done

# Show the usage and exit if no -f argument given
if [ "x" == "x$FWFILE" ]; then
  printf "$USAGE"
  exit 1
fi

# Die if the firmware file doesn't exist
if [ ! -f "$FWFILE" ]; then
    printf "ERROR: $FWFILE does not exist!\n\n";
    exit 2;
fi

# Die if the firmware file isn't readable
if [ ! -r "$FWFILE" ]; then
    printf "ERROR: $FWFILE cannot be read!\n\n";
    exit 2;
fi

function list_usb()
{
while IFS=: read key value; do
  key="${key##+( )}"
  value="${value##+( )}"
  case "$key" in
    "Product ID")
        p="${value% *}"
        ;;
    "Vendor ID")
        v="${value%% *}"
        ;;
    "Manufacturer")
        m="${value}"
        ;;
    "Location ID")
        l="${value}"
        printf "%s:%s %s (%s)\n" "$v" "$p" "$l" "$m"
        ;;
  esac
done < <( system_profiler SPUSBDataType )
}

# Check to see if a native STM32 USB device (Maple device) is attached
uname -a | grep "Darwin" 2>&1 1>/dev/null
if [ $? -eq 0 ]; then
  MAPLE_USB_DEVICES=$(echo "$(list_usb)" | grep "1eaf" | awk '{ print $1}')
else
  MAPLE_USB_DEVICES=$(lsusb | grep "1eaf" | awk '{ print $NF}')
fi

case $MAPLE_USB_DEVICES in 
   ?(0x)1eaf:?(0x)0003)
      MAPLE_DEVICE=DFU
   ;;
   ?(0x)1eaf:?(0x)0004)
      MAPLE_DEVICE=Native
   ;;
   *)
      MAPLE_DEVICE=Unknown
   ;;
esac

# Check if port exists for Maple USB or serial - there is no port needed for DFU
if [ $MAPLE_DEVICE = "Native" ] || [ $MAPLE_DEVICE = "Unknown" ]
then
  # Die if a serial port wasn't specified
  if [ "x" == "x$PORT" ]; then
    printf "$USAGE"
    exit 1
  fi

  # Die if the serial port doesn't exist
  if [ ! -c "$PORT" ]; then
      printf "ERROR: $PORT does not exist!\n\n";
      exit 3;
  fi
fi

# Get the directory where the script is running.
# DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
DIR=$(dirname "$0")

# Set the path to the bootloader file
BOOTLOADERFILE="$DIR/bootloader/StmMulti4in1.bin"

# Determine the binaries to use based on the platform architecture
uname -a | grep "Darwin" 2>&1 1>/dev/null
if [ $? -eq 0 ]; then
  TOOLS_DIR="$DIR/tools/macos"
  GREP_ARGS=""
  STAT_ARGS="-f %z"
else
  uname -m | grep "x86_64" 2>&1 1>/dev/null
  if [ $? -eq 0 ]; then
    TOOLS_DIR="$DIR/tools/64bit"
  else
    TOOLS_DIR="$DIR/tools/32bit"
  fi

  GREP_ARGS="-Pa"
  STAT_ARGS="--printf=%s"
fi

STM32_FLASH="$TOOLS_DIR/stm32flash"
RESET_UTIL="$TOOLS_DIR/maple-reset"
DFU_UTIL="$TOOLS_DIR/dfu-util"

# Determine if the specified firmware file contains support for the STM32 USB port
if grep -q $GREP_ARGS 'M\x00a\x00p\x00l\x00e\x00\x12\x03L\x00e\x00a\x00f\x00L\x00a\x00b\x00s' "$FWFILE"; then
  HAS_USB_SUPPORT=true;
  MAX_FILE_SIZE=120832
  FLASH_START=8
  EXEC_ADDR=0x8002000
else
  HAS_USB_SUPPORT=false;
  MAX_FILE_SIZE=129024
  FLASH_START=0
  EXEC_ADDR=0x8000000
fi

# Check if the firmware will fit
FWFILE_SIZE=`stat $STAT_ARGS "$FWFILE"`
if [ $FWFILE_SIZE -gt $MAX_FILE_SIZE ]; then
    printf "ERROR: Firmware file is too large. File is $FWFILE_SIZE, maximum is $MAX_FILE_SIZE.\n\n";
    exit 2;
fi

# Run the Maple or serial flash
if [[ $MAPLE_DEVICE = "Unknown" ]]
then
  # No Maple device - run the serial flash
  printf "Attempting serial upload using stm32flash\n\n"
  
  if [ ! -x $STM32_FLASH ]; then
    printf "ERROR: Required tool $STM32_FLASH does not exist or is not executable!\n\n"; exit 3;
  fi
  
  STEP=1
  [ "$HAS_USB_SUPPORT" = true ] && NUM_STEPS=3 || NUM_STEPS=2;
  
  printf "[$STEP/$NUM_STEPS] Erasing flash...\n"
  printf "$STM32_FLASH -o -S 0x8000000:129024 -b 115200 \"$PORT\"\n"
  "${STM32_FLASH}" -o -S 0x8000000:129024 -b 115200 "$PORT"
  [ $? -ne 0 ] && printf "ERROR: Failed to erase flash!\n\n" && exit 3;
  STEP=$((STEP+1))
  
  if [ "$HAS_USB_SUPPORT" = true ] ; then
    printf "[$STEP/$NUM_STEPS] Writing bootloader...\n"
    printf "$STM32_FLASH -v -e 0 -g 0x8000000 -b 115200 -w \"$BOOTLOADERFILE\" \"$PORT\"\n"
    "${STM32_FLASH}" -v -e 0 -g 0x8000000 -b 115200 -w "$BOOTLOADERFILE" "$PORT"
    [ $? -ne 0 ] && printf "ERROR: Failed to write bootloader!\n\n" && exit 3;
    STEP=$((STEP+1))
  fi
  
  printf "[$STEP/$NUM_STEPS] Writing firmware...\n"
  printf "$STM32_FLASH -v -s $FLASH_START -e 0 -g $EXEC_ADDR -b 115200 -w \"$FWFILE\" \"$PORT\"\n"
  "${STM32_FLASH}" -v -s $FLASH_START -e 0 -g $EXEC_ADDR -b 115200 -w "$FWFILE" "$PORT"
  [ $? -ne 0 ] && printf "ERROR: Failed to write firmware!\n\n" && exit 3;
    
else
  # Maple device detected
  printf "Attempting USB upload using dfu-util\n\n"

  if [ ! -x $RESET_UTIL ]; then
    printf "ERROR: Required tool $RESET_UTIL does not exist or is not executable!\n\n"; exit 3;
  fi
  
  if [ ! -x $DFU_UTIL ]; then
    printf "ERROR: Required tool $DFU_UTIL does not exist or is not executable!\n\n"; exit 3;
  fi
  
  # Die if the firmware file doesn't contain USB code
  if [ "$HAS_USB_SUPPORT" = false ]; then
    printf "ERROR: Specified firmware file was not compiled with USB support.\nFlashing this file would make the Multiprotocol module unusable.\n\n"; 
    exit 9;
  fi
  
  STEP=1;
  NUM_STEPS=1;
  
  if [[ $MAPLE_DEVICE = "Native" ]] ; then
    NUM_STEPS=2;
    
    printf "[$STEP/$NUM_STEPS] Resetting to DFU mode...\n"
    printf "$RESET_UTIL $PORT\n"
    "${RESET_UTIL}" $PORT
    [ $? -ne 0 ] && printf "ERROR: Failed to reset device!\n\n" && exit 4;
    
    # Give the board a chance to reset to DFU mode
    sleep 1
    
    STEP=$((STEP+1))
  fi
  
  printf "[$STEP/$NUM_STEPS] Writing firmware...\n"
  printf "${DFU_UTIL} -d 1eaf:0003 -a 2 -D \"$FWFILE\" -R\n"
  "${DFU_UTIL}" -d 1eaf:0003 -a 2 -D "$FWFILE" -R
  [ $? -ne 0 ] && printf "\nERROR: Failed to write firmware!\n\n" && exit 5;
  printf "\n";
fi

printf "Firmware flashed successfully.\n\n"
